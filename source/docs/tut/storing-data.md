# 3. Storing Data in a Database

In the previous exercise, we loaded some heroes into the database our application reads from. Now, we will allow our application to store, delete and modify heroes in the database. Before we embark on this part of the journey, it's important that we understand how an HTTP API is intended to work.

## HTTP Resources and Methods

The [HTTP specification](https://tools.ietf.org/html/rfc7231) defines the concept of a *resource*. A resource can be anything - a hero, a bank account, a light switch in your home, a temperature sensor in Antarctica, etc. Some of these things are physical objects (the light switch), and some are digital; they are all still resources. An HTTP server application is an interface to these resources; a client requests that something be done with a resource, and the server finds a way to get it done.

Resources are identified with a URI. A URI *universally identifies* a resource: it has the address of a server to connect to, and a path that identifies the resource on that server. When writing Aqueduct applications, we don't care much about the server part of a URL - the internet figures out that part. What we do care about is the path of the URL - like `/heroes`.

An application use the URL path to determine which resource the request wants to work with. Right now, our application works with hero resources. A request with the path `/heroes/1` wants to do something with an individual hero (that is identified by the number `1`). A request with the path `/heroes` will act on the entire collection of heroes.

These actions are primarily described by the request method (like GET, POST, OR DELETE). Each of these methods has a general meaning that describes an action that can be applied to a resource. For example, a `GET /heroes` means "get me all of the hero resources". The meaning for each of these methods are as follows:

- GET: returns a collection of some resource or an individual resource
- POST: inserts or appends a resource to a collection of some resource; a representation of the resource is in the request body
- PUT: replaces a resource with the contents of the request body (or in some cases, replaces the entire collection of some resource)
- DELETE: deletes a resource (or in some cases, deletes the entire collection of some resource)

It turns out, we can create a lot of incredible behavior by just combining these methods and a request path. More importantly, by following these specifications, client applications can use generic libraries to access any HTTP API with very little effort. This allows us to create complex systems that are easily made available to a browser, mobile phone or any other internet-connected device.

## Inserting Data

We'll start by adding behavior that allows for new heroes to be inserted into the database. Following our previous discussion, the HTTP request must take the form `POST /heroes` - we are appending a new hero to the collection of heroes. This request will contain the JSON representation of a hero in its body, for example:

```json
{
  "name": "Master of Aqueducts"
}
```

Our `HeroesController` will handle this operation. In general, a single endpoint controller should handle every operation on a resource collection and its individual resources. In `heroes_controller.dart`, add the following operation method:

```dart
@Operation.post()
Future<Response> createHero() async {
  final body = request.body.asMap();
  final query = new Query<Hero>(context)
    ..values.name = body['name'];

  final insertedHero = await query.insert();

  return new Response.ok(insertedHero);
}
```

This operation method grabs the hero from the request's body, constructs a query that inserts that hero, and then returns it in the response.

Using a `Query<Hero>` to insert a row isn't very different than using one to fetch rows. When inserting a row, we execute `query.insert()` instead of `query.fetch()`. Instead of applying matchers to `query.where`, we set the properties of `query.value`. Like `where`, `values` is also an instance of  `Hero`. Each property we set on `values` is sent in an `INSERT` command to the database. The generated SQL for the above would be something like:

```sql
INSERT INTO _Hero (name) VALUES ('Hero Name');
```

The database automatically generates a value for the `id` property of a `Hero`. This is because `id` has a `primaryKey` annotation that marks it as "auto-incrementing". (See [the API reference for Column](https://www.dartdocs.org/documentation/aqueduct/latest/aqueduct/Column-class.html) for details and options.) When the row has been successfully inserted, a new `Hero` object is returned - containing any values that were generated by the database.

Re-run your application. In the browser application, click on `Heroes` near the top of the page. Then, enter a name into the `Hero name:` field and click `Add`. The new hero will appear. You can re-run the application and that hero will still be available, because it has been stored in the database on your machine.

![Insert Hero](../img/run3.png)

!!! tip "Sub-resources"
    We mentioned that a single controller should handle every operation for a resource collection and its individual resources. Some resources are complex enough that they can have sub-resources. For example, an organization of heroes (like the X-Men or Fantastic Four) contains heroes, but it might also contain buildings and equipment owned by the organization. The heroes, buildings and equipment are sub-resources of an organization.  Each sub-resource should have its own route and controller instead of trying to shove everything into a single route and controller. See the following code snippet for an example.

```dart
@override
Controller get entryPoint {
  return new Router()
    ..route("/organizations/[:orgName]")
      .link(() => new OrganizationController());
    ..route("/organizations/:orgName/heroes/[:heroID]")
      .link(() => new OrgHeroesController());
    ..route("/organizations/:orgName/buildings/[:buildingID]")
      .link(() => new OrgBuildingController());
}
```    

## Request and Response Bodies

So far, we've largely glossed over how request and response bodies are handled, and now is a good time to dig in to this topic.

When we create a response, we specify its status code and optionally its headers and body. For example, the following creates a response with a status code of 200 OK with an empty list body:

```dart
new Response.ok([])
```

The first argument to `Response.ok` is a *body object*. When the response is sent to a client, the body object is encoded according to the `contentType` of the response. By default, the content type of a response is `application/json` - so by default, all of our response body objects have been JSON-encoded into the response body.

!!! note "Other Response Constructors"
    The default constructor for a `Response` takes a status code, map of headers and a body object - e.g., `Response(200, {}, "body")`. There are many named constructors for `Response`, like `Response.ok` or `Response.notFound`. These constructors set the status code and expose parameters that are intended for that type of response. For example, a 200 OK response should have a body, so `Response.ok` has a required body object argument. See [the API reference for Response](https://www.dartdocs.org/documentation/aqueduct/latest/aqueduct/Response-class.html) for possible constructors and properties of a response.

As long as an object can be JSON encoded, it can be the body object of a response with JSON content-type. In general, this includes objects that are strings, integers, doubles, and maps and lists that contain those types (you can verify if your object is encodable by invoking `JSON.encode` from `dart:convert`).

To change how a body object is encoded, you set the `contentType` of the response. For example,

```dart
new Response.ok([])
  ..contentType = new ContentType("application", "xml");
```

The default supported content types are JSON, `application/x-www-form-urlencoded` and all `text/*` types. To encode other content-types, you must register a `Codec` with `HTTPCodecRepository.`

These codecs are are also responsible for decoding request bodies. The body of a request is accessible through the `Request.body` property.

----
----
----

It also includes types that implement `HTTPSerializable`, which `ManagedObject<T>` does.




It is often safer and more convenient to bind the body to a parameter of our operation method, instead of manually managing `request.body`. Update `createHero()`:

```dart
@Operation.post()
Future<Response> createHero(@Bind.body() Hero inputHero) async {
  final query = new Query<Hero>(context)
    ..values = inputHero;

  final insertedHero = await query.insert(context);

  return new Response.ok(insertedHero);
}
```

Binding a request body will automatically deserialize the decoded contents of the request body into an object. That object's type must implement the interface `HTTPSerializable`, which all `ManagedObject<T>`s do. Properties of the `inputHero` will be set from the decoded request body map when the JSON key matches the name of the property. If deserializing the request body into a `Hero` instance fails for any reason, a 400 Bad Request response is sent and the operation method is not called.



An insert query creates a row in the database. The values for each column are provided through the `Query.values` property. Like `Query.where`, `Query.values` is also an instance of a `Hero` and therefore has an `id` and `name` property.

Re-run your `heroes` application. On [http://aqueduct-tutorial.stablekernel.io](http://aqueduct-tutorial.stablekernel.io), click on the `Heroes` button on the top of the screen. In the text field, enter a new hero name and click `Add`. You'll see your new hero added to the list! You can shutdown your application and run it again and you'll still be able to fetch your new hero.

![Aqueduct Tutorial Third Run](../img/run3.png)

!!! tip "Query Construction"
    Properties like `values` and `where` prevent errors by type and name checking columns with the analyzer. They're also great for speeding up writing code because your IDE will autocomplete property names. There is [specific behavior](../db/advanced_queries.md) a query uses to decide whether it should include a value from these two properties in the SQL it generates.
