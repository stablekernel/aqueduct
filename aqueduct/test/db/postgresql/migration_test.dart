import 'dart:async';

import 'package:aqueduct/aqueduct.dart';
import 'package:postgres/postgres.dart';
import 'package:test/test.dart';

/*
The purpose of these tests is to ensure that the SQL generated by diff'ing a schema creates the desired database.
These tests run queries against a database after it has been manipulated to ensure that the intended effect is met.
 */

void main() {
  PostgreSQLPersistentStore store;
  SchemaBuilder builder;

  setUp(() async {
    store = PostgreSQLPersistentStore(
        "dart", "dart", "localhost", 5432, "dart_test");
  });

  test(
      "The order of related tables in the schema does not matter when creating/deleting",
      () async {
    // This test runs the following closure for two different schema sequences, where related tables
    // are added to the schema one before the other to ensure that the order they are added to that
    // schema doesn't matter when generating the schema in the database
    final run = (List<Schema> schemas) async {
      await applyDifference(store, schemas[0], schemas[1]);
      expect(await store.execute("INSERT INTO t (id) VALUES (1) RETURNING *"), [
        [1]
      ]);
      expect(
          await store.execute(
              "INSERT INTO u (id, ref_id) VALUES (1, 1) RETURNING id, ref_id"),
          [
            [1, 1]
          ]);
      await applyDifference(store, schemas[1], schemas[2]);

      try {
        await store.execute("INSERT INTO t (id) VALUES (2) RETURNING *");
        fail('unreachable');
      } on PostgreSQLException catch (e) {
        expect(e.toString(), contains("does not exist"));
      }

      try {
        await store
            .execute("INSERT INTO u (id, ref_id) VALUES (2, 1) RETURNING *");
        fail('unreachable');
      } on PostgreSQLException catch (e) {
        expect(e.toString(), contains("does not exist"));
      }
    };

    await run([
      Schema.empty(),
      Schema([
        SchemaTable("u", [
          SchemaColumn("id", ManagedPropertyType.integer, isPrimaryKey: true),
          SchemaColumn.relationship("ref", ManagedPropertyType.integer,
              relatedTableName: "t", relatedColumnName: "id")
        ]),
        SchemaTable("t", [
          SchemaColumn("id", ManagedPropertyType.integer, isPrimaryKey: true)
        ]),
      ]),
      Schema.empty()
    ]);
    await run([
      Schema.empty(),
      Schema([
        SchemaTable("t", [
          SchemaColumn("id", ManagedPropertyType.integer, isPrimaryKey: true)
        ]),
        SchemaTable("u", [
          SchemaColumn("id", ManagedPropertyType.integer, isPrimaryKey: true),
          SchemaColumn.relationship("ref", ManagedPropertyType.integer,
              relatedTableName: "t", relatedColumnName: "id")
        ]),
      ]),
      Schema.empty()
    ]);
  });

  test("Add table to schema", () async {
    final cmds = await applyDifference(
        store,
        Schema.empty(),
        Schema([
          SchemaTable("foo", [
            SchemaColumn("id", ManagedPropertyType.integer, isPrimaryKey: true)
          ])
        ]));

    expect(cmds.length, 1);

    expect(await store.execute("INSERT INTO foo (id) VALUES (1) RETURNING *"), [
      [1]
    ]);
  });

  test("Add a table with a foreign key to an existing table", () async {
    final schemas = [
      Schema.empty(),
      Schema([
        SchemaTable("t", [
          SchemaColumn("id", ManagedPropertyType.integer, isPrimaryKey: true)
        ]),
      ]),
      Schema([
        SchemaTable("t", [
          SchemaColumn("id", ManagedPropertyType.integer, isPrimaryKey: true)
        ]),
        SchemaTable("u", [
          SchemaColumn("id", ManagedPropertyType.integer, isPrimaryKey: true),
          SchemaColumn.relationship("ref", ManagedPropertyType.integer,
              relatedTableName: "t", relatedColumnName: "id")
        ]),
      ])
    ];

    await applyDifference(store, schemas[0], schemas[1]);
    await applyDifference(store, schemas[1], schemas[2]);

    await store.execute("INSERT INTO t (id) VALUES (1)");
    final results = await store.execute(
        "INSERT INTO u (id, ref_id) VALUES (1, 1) RETURNING id, ref_id");
    expect(results, [
      [1, 1]
    ]);
  });

  test(
      "Add a new table and a foreign key from an existing table to the new table",
      () async {
    final schemas = [
      Schema.empty(),
      Schema([
        SchemaTable("u", [
          SchemaColumn("id", ManagedPropertyType.integer, isPrimaryKey: true)
        ]),
      ]),
      Schema([
        SchemaTable("u", [
          SchemaColumn("id", ManagedPropertyType.integer, isPrimaryKey: true),
          SchemaColumn.relationship("ref", ManagedPropertyType.integer,
              relatedTableName: "t", relatedColumnName: "id")
        ]),
        SchemaTable("t", [
          SchemaColumn("id", ManagedPropertyType.integer, isPrimaryKey: true),
        ]),
      ])
    ];

    await applyDifference(store, schemas[0], schemas[1]);
    await applyDifference(store, schemas[1], schemas[2]);

    await store.execute("INSERT INTO t (id) VALUES (1)");
    var results = await store.execute(
        "INSERT INTO u (id, ref_id) VALUES (1, 1) RETURNING id, ref_id");
    expect(results, [
      [1, 1]
    ]);
  });

  test("Add unique constraint to table", () async {
    final schemas = [
      Schema.empty(),
      Schema([
        SchemaTable("u", [
          SchemaColumn("id", ManagedPropertyType.integer, isPrimaryKey: true),
          SchemaColumn("a", ManagedPropertyType.integer)
        ]),
      ]),
      Schema([
        SchemaTable("u", [
          SchemaColumn("id", ManagedPropertyType.integer, isPrimaryKey: true),
          SchemaColumn("a", ManagedPropertyType.integer),
          SchemaColumn("b", ManagedPropertyType.integer, isNullable: true),
        ], uniqueColumnSetNames: [
          "a",
          "b"
        ]),
      ])
    ];

    await applyDifference(store, schemas[0], schemas[1]);
    await applyDifference(store, schemas[1], schemas[2]);

    await store.execute("INSERT INTO u (id,a,b) VALUES (1,1,1)");
    try {
      await store.execute("INSERT INTO u (id,a,b) VALUES (2,1,1)");
      fail('unreachable');
    } on QueryException catch (e) {
      expect(
          e.underlyingException.toString(),
          contains(
              "duplicate key value violates unique constraint \"u_unique_idx\""));
    }
  });

  test("Remove unique constraint from table", () async {
    final schemas = [
      Schema.empty(),
      Schema([
        SchemaTable("u", [
          SchemaColumn("id", ManagedPropertyType.integer, isPrimaryKey: true),
          SchemaColumn("a", ManagedPropertyType.integer),
          SchemaColumn("b", ManagedPropertyType.integer)
        ], uniqueColumnSetNames: [
          "a",
          "b"
        ]),
      ]),
      Schema([
        SchemaTable("u", [
          SchemaColumn("id", ManagedPropertyType.integer, isPrimaryKey: true),
          SchemaColumn("a", ManagedPropertyType.integer),
          SchemaColumn("b", ManagedPropertyType.integer),
        ]),
      ])
    ];

    await applyDifference(store, schemas[0], schemas[1]);
    await applyDifference(store, schemas[1], schemas[2]);

    await store.execute("INSERT INTO u (id,a,b) VALUES (1,1,1)");
    var y = await store.execute("INSERT INTO u (id,a,b) VALUES (2,1,1)");
    expect(y, isNotNull);
  });

  test("Modify unique constraint on table", () async {
    final schemas = [
      Schema.empty(),
      Schema([
        SchemaTable("u", [
          SchemaColumn("id", ManagedPropertyType.integer, isPrimaryKey: true),
          SchemaColumn("a", ManagedPropertyType.integer),
          SchemaColumn("b", ManagedPropertyType.integer)
        ], uniqueColumnSetNames: [
          "a",
          "b"
        ]),
      ]),
      Schema([
        SchemaTable("u", [
          SchemaColumn("id", ManagedPropertyType.integer, isPrimaryKey: true),
          SchemaColumn("a", ManagedPropertyType.integer),
          SchemaColumn("b", ManagedPropertyType.integer),
          SchemaColumn("c", ManagedPropertyType.integer, isNullable: true)
        ], uniqueColumnSetNames: [
          "b",
          "c"
        ]),
      ])
    ];

    await applyDifference(store, schemas[0], schemas[1]);
    await applyDifference(store, schemas[1], schemas[2]);

    await store.execute("INSERT INTO u (id,a,b,c) VALUES (1,1,1,1)");
    var y = await store.execute("INSERT INTO u (id,a,b,c) VALUES (2,1,1,2)");
    expect(y, isNotNull);

    try {
      await store.execute("INSERT INTO u (id,a,b,c) VALUES (3,5,1,1)");
      fail('unreachable');
    } on QueryException catch (e) {
      expect(
        e.underlyingException.toString(),
        contains(
          "duplicate key value violates unique constraint \"u_unique_idx\""));
    }
  });
}

Future<List<String>> applyDifference(
    PersistentStore store, Schema baseSchema, Schema newSchema) async {
  final diff = baseSchema.differenceFrom(newSchema);
  final commands =
      SchemaBuilder.fromDifference(store, diff, isTemporary: true).commands;

  await Future.forEach(commands, (String c) => store.execute(c));

  return commands;
}
