---
layout: page
title: "1. Routing and Request Handling"
category: tut
date: 2016-06-20 10:35:56
order: 1
---

Purpose
---

The purpose of this tutorial series is to become familiar with how Aqueduct works. This tutorial will build a web server from scratch. After getting comfortable, it is advised to use the template generator in Aqueduct to create new projects. Additionally, this tutorial will use Atom for editing code. Again, once comfortable, IntelliJ IDEA Community Edition is a more powerful editor.

Installing Dart
---

If you have Homebrew installed, run these commands from terminal:

```bash
brew tap dart-lang/dart
brew install dart
```

If you don't have Homebrew installed or you are on another platform, visit [https://www.dartlang.org/install](https://www.dartlang.org/install). It'll be quick, promise.

You should install Atom for editing your Dart code. You can get it from [https://atom.io](https://atom.io). Once Atom is installed, install the 'dartlang' package from 'dart-atom' (not any of the other ones that have a similar name).  

Creating a Project
---

Create a new directory named `quiz` (ensure that it is lowercase). Within this directory, create a new file named `pubspec.yaml`. Dart uses this file to define your project and its dependencies (like iOS' `Info.plist` or Android's `AndroidManifest.xml`).

In the pubspec, enter the following markup:

```yaml
name: quiz
description: A quiz web server
version: 0.0.1
author: Thor Odinson <thor@asgard.yg>

environment:
  sdk: '>=1.20.0 <2.0.0'

dependencies:
  aqueduct: any  
```

This pubspec declares an application named `quiz` (all Dart files, directories and application identifiers are snake_case), indicates that it can use a version of the Dart SDK between 1.20 and 2.0, and depends on the `aqueduct` package.

Next, you will fetch the dependencies of the `quiz` project - this will fetch the source for `aqueduct` from Dart's hosted package manager. If you are using Atom, you'll get a popup that tells you to do this and you can just click the button. (You may also right-click on file in Atom and select 'Pub Get'). If you aren't using Atom, from the command line, run the following from inside the `quiz` directory:

```bash
pub get
```

Dependencies get stored in the global cache directory, `~/.pub-cache`. Dependencies are referenced by files in your project's directory. These files are automatically generated by the previous command. You won't have to worry about that, though, since you'll never have to deal with it directly. Sometimes, it's just nice to know where things are. (There is one other file, called `pubspec.lock` that you do care about, but we'll chat about it later.)

With this dependency installed, your project can use Aqueduct. For this simple getting started guide, we won't structure a full project and just focus on getting an Aqueduct web server up and running. Create a new directory named `bin` and add a file to it named `quiz.dart`. At the top of this file, import the Aqueduct package and the `async` standard library:

```dart
import 'package:aqueduct/aqueduct.dart';
import 'dart:async';
```

Handling Requests
---

The structure of Aqueduct is like most server-side frameworks: requests go to a router, which then get sent off to a series of request controllers. There are many kinds of request controllers available in Aqueduct for different tasks and different levels of abstraction. The most commonly used controller is `HTTPController`. We'll create a `HTTPController` subclass that will respond to requests by returning a list of questions in JSON. In `quiz.dart`, create this subclass:

```dart
class QuestionController extends HTTPController {
  var questions = [
    "How much wood can a woodchuck chuck?",
    "What's the tallest mountain in the world?"
  ];

  @httpGet Future<Response> getAllQuestions() async {
    return new Response.ok(questions);
  }
}
```

The `QuestionController` class defines a property named `questions` that has a list of strings. Then, it defines a *responder method* called `getAllQuestions`. Responder methods in an `HTTPController` are responsible for responding to a request. To be a responder method in an `HTTPController`, it must have `HTTPMethod` metadata that indicates which HTTP method it responds to. In this case, the `httpGet` metadata indicates `getAllQuestions` will respond to HTTP GET requests. There are built-in constants for the common HTTP methods - like `@httpPut`, `@httpPost` - which are all instances of `HTTPMethod`.

A responder method must return an instance of `Future<Response>`. A `Response` always has a status code. There are built-in convenience constructors for common status codes. In this example, `Response.ok` creates a `Response` with status code 200. Depending on the convenience constructor used, the argument may mean something different. In the case of `Response.ok`, the argument is an object that will be encoded as the HTTP response body.

When an HTTP GET gets routed to a `QuestionController`, a response with status code 200 and body containing a list of questions will be sent. By default, the response object - here, `questions` - gets encoded as JSON before being sent. (We'll see how that customize that much later.)

Because responder methods in `HTTPController` must always return a `Response` and must always have `HTTPMethod` metadata, its acceptable to omit the return type to make the method signature more readable:

```dart
@httpGet getAllQuestions() async {
  return new Response.ok(questions);
}
```

Right now, this `QuestionController` is set up to respond to a request, but it doesn't have requests to handle yet. We need to listen for HTTP requests and feed them to instances of `QuestionController` so that it may respond.

For this, there is a class called `Application`. An application instance manages starting up an HTTP listener and relaying requests into application-specific code. In any Aqueduct application, there is one instance of `Application`. We'll see more on that in a moment.

That application-specific code starts in a subclass of `RequestSink`. When an HTTP request is made, the application receives it and places it into a `RequestSink`. A request sink defines how requests get routed and eventually responded to. A `RequestSink` defines one or more streams of `RequestController`s that the request will travel in until it is responded to.

At the bottom of `quiz.dart`, create a `RequestSink` subclass:

```dart
class QuizRequestSink extends RequestSink {
  QuizRequestSink(Map<String, dynamic> options) : super (options);
}
```

A `RequestSink` subclass must have a constructor that takes a `Map<String, dynamic>` of options and forward it on to its superclass' constructor. These values are provided by a configuration file and are typically used to configure a `RequestSink`'s properties - like a database connection. Since the `quiz` app doesn't do much right now, we simply forward the configuration options on to the `super`'s constructor as required.

Both `RequestSink` and `HTTPController` are subclasses of `RequestController` - and therefore, both `QuizRequestSink` and `QuestionController` are as well.
A `RequestController` receives `Request`s from another `RequestController` and either responds to that request or passes it down the stream to the next `RequestController`. Thus, `RequestController`s are chained together to create a stream that a request travels in. A `RequestSink` is special in that it receives `Request`s from the `Application`, and is therefore the first controller in the stream.

By default, a `RequestSink` subclass simply forwards `Request`s to its `initialController`. The default `initialController` is the `RequestSink`'s `router`, which is an instance of `Router`. A `Router` splits the stream of HTTP requests based on their path. Each of these splits is called a *route*. Subsequent `RequestController`s are chained to each route. The setup for each route and the stream of `RequestController`s is defined in a `RequestSink.setupRouter` required method. In this application, we'd like all HTTP requests with the path `/questions` to go to our `QuestionController`. Implement this method in `QuizRequestSink`:

```dart
class QuizRequestSink extends RequestSink {
  QuizRequestSink(Map<String, dynamic> options) : super (options);

  @override
  void setupRouter(Router router) {
    router
      .route("/questions")
      .generate(() => new QuestionController());
  }
}
```

There are a few things to notice here. First, a `Router` - the type of `router` - is a subclass of `RequestController` as well. This means it can receive `Request` events and either respond to them or pass them downstream. When a `Router` gets a `Request` event, it looks at all of its registered routes to find one that matches the path of the `Request`. Routes are registered through the `route` method.

The `route` method method creates an instance of `RouteController` (which is also a `RequestController` subclass - are you seeing the pattern?). When a router matches the path of an HTTP request to one of its registered routes, the `Request` event is sent to the associated `RouteController`. If no registered route matches the path of the request, the `Router` responds to the `Request` with a 404 status code and drops the `Request` event.

A `RouteController` doesn't do anything with a `Request`, it simply forwards it downstream. Thus, the `setupRouter` method must chain another `RequestController` to each `RouteController`. In this example, the next controller is added by the `generate` method. The `generate` method takes a closure that returns an instance of some `RequestController`. Each time the previous controller emits a `Request` event to a `generate`d stream, the closure is called, creating a new instance of a `RequestController`, and the `Request` is delivered to that new instance. Here, that new instance is an instance of our `QuestionController`.

We'll get to the specifics of all of that in a moment, but we're almost to the point that we can run this web server, and that seems more exciting. With a `RequestSink` and a route hooked up to our `QuestionController`, we can write code that starts the web server. At the top of `quiz.dart`, underneath the import, define a `main` function like so:

```dart
import 'package:aqueduct/aqueduct.dart';
import 'dart:async';

void main() {
  var app = new Application<QuizRequestSink>();
  app.start();
}
```

To run the application if you are using Atom, you can right-click on `quiz.dart` and select 'Run Application'. If you wish to run from the command line, run the following from the `quiz` directory:

```bash
pub run quiz
```

In a browser, open the URL `http://localhost:8080/questions`. You'll see the list of questions! (You can shut down the server by click 'Stop' in the run panel in Atom, or if running from the command line, hitting Ctrl-C in the command line.)

Magic is for children - so what happened?
---

Every Dart application starts in a `main` function. In most languages, the program will terminate once main is done executing, but Dart is not most languages. Instead, if there are any open `Stream`s still listening for events, the program will continue to run after main has finished. Therefore, main is more of a 'start' than anything else.

Your `main` function creates an instance of `Application`, which opens a specific kind of `Stream`, an `HttpServer`.

When an application is started, it creates an instance of its `RequestSink`, which is defined by its type argument; in this case, `QuizRequestSink`. As `Request`s come in, the `Application` forwards them to instances of its `RequestSink`. From there, your application-specific code takes over.

In the previous code, you set up a `Router` to pass `Request`s with the route `/questions` to a `QuestionController` generator. If you trace the lifetime of a `Request` with a path of `/questions` throughout this application, the following occurs:

1. A standard library `HttpRequest` is added to the `HttpServer`'s stream.
2. The `Application` instance listening on the `HttpServer`'s stream wraps the `HttpRequest` in an Aqueduct `Request` object and sends it to the `QuizRequestSink`.
3. The `QuizRequestSink` immediately forwards the `Request` to its `Router`.
4. The `Router` matches the path of the `Request` to the `/questions` route, and forwards the `Request` to the associated `RouteController`.
5. The `RouteController` immediately forwards the `Request` to the generator, which creates an instance of `QuestionController` to which the `Request` is delivered to.
6. The `QuestionController` matches the HTTP method ('GET') to its responder method, `getAllQuestions`.
7. `getAllQuestions` is invoked and a `Response` is returned.
8. The base behavior of `RequestController` encodes the body as JSON and writes the response back to the HTTP client.

![Application Diagram](../images/ch01/pipelinediagram.png)

This is the life of most `Request`s in an Aqueduct application. The stream of `RequestController`s must result in a `Response` at some point. Along the way, any `RequestController` may choose to respond to a `Request`, which prevents it from continuing down the stream. For example, a `Router` will respond with a 404 if no registered route matches. Some controllers, like subclasses of `HTTPController`, always respond to their request and therefore chaining subsequent controllers doesn't make much sense. (In the future, Aqueduct may have 'post-processing' controllers, but for now, it does not.)

All `RequestController`s have three variants for how `Request` events are passed on to the next `RequestController`. In this example, you used `generate` - which creates a new instance of a `RequestController` for each request. Other options are `listen` and `pipe`, and `Router`s have a special chaining method `route`. Each one of these has a different reason to be used, but that discussion is contained in the guide for `RequestController`s. For now, note that subclasses of `HTTPController` must be generated.

The setup of these streams must be created in a `RequestSink`s `setupRouter` method. Once routes are added, the `Router` gets 'compiled' for optimization purposes. Adding more routes to a `Router` after it has been finalized will yield an exception.

Routing and Another Route
---

So far, we've added a route that matches the constant string `/questions`. Routers can do more than match a constant string, they can also include path variables, optional path components, regular expression matching and the wildcard character. We'll add to the existing `/questions` route by allowing requests to get a specific question.

In `quiz.dart`, modify the code in the `QuizRequestSink.setupRouter` by adding "/[:index]" to the route.

```dart
  @override
  void setupRouter(Router router) {
    router
        .route("/questions/[:index]")
        .generate(() => new QuestionController());
  }
```

The square brackets indicate that part of the path is optional, and the colon indicates that it is a path variable. A path variable matches anything. Therefore, this route will match if the path is `/questions` or `/questions/2` or `/questions/foo`.

When using path variables, you may optionally restrict which values they match with a regular expression. The regular expression syntax goes into parentheses after the path variable name. Let's restrict the `index` path variable to only numbers:

```dart
  @override
  void setupRouter(Router router) {
    router
        .route("/questions/[:index(\\d+)]")
        .generate(() => new QuestionController());
  }
```

Now, there are two types of requests that will get forwarded to a `QuestionController` - a request for all questions (`/questions`) and and a request for a specific question at some index (`/questions/1`). We need to add a new responder method to `QuestionController` that gets called when the latter request is made:

```dart
class QuestionController extends HTTPController {
  var questions = [
    "How much wood can a woodchuck chuck?",
    "What's the tallest mountain in the world?"
  ];

  @httpGet getAllQuestions() async {
    return new Response.ok(questions);
  }

  @httpGet getQuestionAtIndex(@HTTPPath("index") int index) async {
    if (index < 0 || index >= questions.length) {
      return new Response.notFound();
    }

    return new Response.ok(questions[index]);  
  }
}
```

Make sure you've stopped the application from running, and then run the application again. In your browser, enter `http://localhost:8080/questions` and you'll get the list of questions. Then, enter `http://localhost:8080/questions/0` and you'll get the first question. If you enter an index not within the list of questions or something other than an integer, you'll get a 404.

When a `Request` is sent to an `HTTPController`, it evaluates the HTTP method of the request and matches it against every declared responder method. In this case, the `HTTPController` will have two possible choices: `getQuestions` and `getQuestionAtIndex`. From here, it looks at the parameters for each of the methods and the path variables in the `Request`.

Parameters with `HTTPPath` metadata are used to match path variables from the `Request`. If there are no path variables, the no-argument `getAllQuestions` is invoked. If there is one `HTTPPath` argument *and* the name of the path variable is named `index` (the `String` argument to `HTTPPath`), then `getQuestionAtIndex` is called. The name of the path variable is defined by the name of the variable declared in `Router`'s `route` method.

If neither of those scenarios are true, the `HTTPController` responds with 404 and doesn't call any of your responder methods. Because the route is declared to also evaluate a regular expression that restricts `index` to only numeric values, non-numeric values in the `index` portion of the route will also yield a 404. You can try that be hitting `http://localhost:8080/questions/foo` from your browser.

This HTTP method and path variable matching behavior is specific to `HTTPController`.

The More You Know: Multi-threading and Application State
---
In this simple exercise, we used a constant list of question as the source of data for the questions endpoint. For a simple getting-your-feet-wet demo, this is fine.

However, in a real application, it is important that we don't keep any mutable state in a `RequestSink` or any `RequestController`s. This is for three reasons. First, it's just bad practice - web servers should be stateless. They are facilitators between a client and a repository of data, not a repository of data themselves. A repository of data is typically a database.

Second, the way Aqueduct applications are structured makes it really difficult to keep state. For example, `HTTPController` is instantiated each time a new request comes in. Any state they have is discarded after the request is finished processing. This is intentional - you won't run into an issue when scaling to multiple server instances in the future, because the code is already structured to be stateless.

Finally, isolates. Aqueduct applications are set up to run on multiple isolates (the `numberOfInstances` argument for the `Application`'s `start` method). An isolate is effectively a thread that shares no memory with other threads. If we were to keep track of state in some way, that state would not be reflected across all of the isolates running on this web server. So depending on which isolate grabbed a request, it may have different state than you might expect. Again, Aqueduct forces you into this model on purpose.

Isolates will spread themselves out across CPUs on the host machine. Each isolate will have its own instance of your `RequestSink` subclass. Having multiple isolates running the same stateless web server on one machine allows for faster request handling. Each isolate also maintains its own set of resources, like database connections.

## [Next Chapter: Writing Tests](writing-tests.html)
