---
layout: page
title: "Handling Requests"
category: http
date: 2016-06-19 21:22:35
order: 4
---

For every HTTP request, an instance of [Request](request_and_response.html) is created. A `RequestController` creates a `Response` for a request. Sometimes. Other times, a controller does something with the request and then passes it on to another.

Aqueduct applications are just a bunch of `RequestController`s strung together like a real life assembly line. In an assembly line of cars, the body of a car gets put on a conveyor belt. The first worker puts on a steering wheel, the next puts on tires and the last one paints the car a color. The car is then removed from the conveyor belt and sold. Each worker has a specific job in a specific order - they rely on the rest of the assembly line to complete the car, but their job is isolated.

This conveyor belt is built by chaining together `RequestController`s with methods like `pipe` and `generate`. Here's an example of some common Aqueduct code:

```dart
var router = new Router();
router
  .route("/users")
  .pipe(new Authorizer(authServer))
  .generate(() => new UserController());
```

This chains together a `Router`, an `Authorizer` and a `UserController` - all subclasses of `RequestController`. So, let's say this router gets a request - if the path matches `/users`, it goes to the `Authorizer`, and if its authorized, it goes to a `UserController`, which responds to the request.

A request can drop out of the assembly line before it reaches the end. If the request's path didn't match `/users`, a 404 response would be created and the request would never get to the `Authorizer`. If the request wasn't authorized, a 401 response would be created and the request would never get to the `UserController`.

More generally, `RequestController`s take a `Request` as input. If they want to respond to the request, they create a response. Otherwise, they send the request to the next controller in line.

Both `pipe` and `generate` set up this relationship between controllers; difference being that `generate` creates a new instance of the controller each time a request comes through and `pipe` just reuses the same one. (That's why the argument is a closure that creates a new `UserController` in this example, not just a `UserController` instance.)

The reason this distinction exists is because some controllers will have properties that reference the request they are currently processing. Since Aqueduct applications handle multiple `Request`s at a time, these controllers would get their properties changed while waiting for an asynchronous operation to complete if there were only one instance.

The most commonly used controller - [HTTPController](http_controller.html) - must be generated, whereas an `Authorizer` holds no state and does not. `RequestController` subclasses that require generation have `@cannotBeReused` metadata and will throw an exception immediately at startup if not.

There's also a `listen` method that takes a closure to process the request instead of an object (that closure still gets wrapped in a `RequestController` under the hood):

```dart
var router = new Router();
router
  .route("/health")
  .listen((req) async => new Response.ok(null));
```

The `route` method is unique to a `Router`, but allows for multiple controllers to be chained to the router based on their request path. There's a whole section on [Routing](routing.html).

`RequestController`s serve as the building blocks of an Aqueduct application, but they are rarely used directly. More often than not, an Aqueduct application is built entirely out of [Router](routing.html), [Authorizer](../auth/authorizer.html) and [HTTPController](http_controller.html) subclasses.

## Exception Handling

If an exception is thrown while processing a request, it will be caught by the `RequestController` doing the processing. The controller will respond with an appropriate status code and the request is discarded so no more controllers will see it.

There are two types of exceptions that a `RequestController` will interpret to return a meaningful status code: `HTTPResponseException` and `QueryException`. Any other uncaught exceptions will result in a 500 status code error.

`QueryException`s are generated by the Aqueduct ORM. A request controller interprets these types of exceptions to return a suitable status code. The following reasons for the exception generate the following status codes:

|Reason|Status Code|
|---|---|
|A programmer error (bad query syntax)|500|
|Unique constraint violated|409|
|Invalid input|400|
|Database can't be reached|503|

An `HTTPResponseException` can be thrown at anytime to escape early from processing and return a response. Exceptions of these type allow you to specify the status code and a message. The message is encoded in a JSON object for the key "error". Some classes in Aqueduct will throw an exception of this kind if some precondition isn't met. You may add your own try-catch blocks to request processing code to either catch and reinterpret the behavior of `HTTPResponseException` and `QueryException`, or for any other reason.

Other than `HTTPResponseException`s, exceptions are always logged along with some details of the request that generated the exception. `HTTPResponseException`s are not logged, as they are used for control flow and are considered "normal" operation.

## Subclassing RequestController

Using existing subclasses of `RequestController` like `Router`, `Authorizer` and `HTTPController` cover the majority of Aqueduct use cases. There are times where creating your own `RequestController` subclass may make sense.

Subclassing `RequestController` usually involves overriding its `processRequest` method. This method takes a `Request` as input and returns either a `Response` or `Request` wrapped in a `Future`.

```dart
class Controller extends RequestController {
  @override
  Future<RequestOrResponse> processRequest(Request request) async {
      ... return either request or a new Response ...
  }
}
```

A controller receives `Request`s in this method. If this method returns a `Response`, that response is sent to the HTTP client and no more processing occurs. If this method returns a `Request`, the next controller in the assembly line has this method invoked.

A controller must return the same instance of `Request` it receives, but it may attach additional information by adding key-value pairs to the request's `attachments`.

For example, an `Authorizer`'s pseudo code looks like this:

```dart
Future<RequestOrResponse> processRequest(Request request) async {
    if (!isAuthorized(request)) {
      return new Response.unauthorized();
    }

    request.attachments["authInfo"] = authInfoFromRequest(request);
    return request;
}
```

It's important that the last controller in the assembly line always responds to a request. Typically, this is an instance of an `HTTPController` subclass.

Aqueduct automatically invokes `processRequest` on controllers inside a try-catch block. This allows uncaught errors to always send a response to the HTTP client and attaches things like CORS headers.
