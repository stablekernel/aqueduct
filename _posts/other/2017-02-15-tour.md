---
layout: page
title: "Aqueduct: The Tour"
category: other
date: 2016-06-19 21:22:35
order: 1
---

The purpose of this document is briefly touch on the Aqueduct framework and its usage. More detailed documentation is available elsewhere on http://stablekernel.github.io/aqueduct and https://www.dartdocs.org/documentation/aqueduct/latest.


### Creating Applications

Create applications with the command line tool:

```
aqueduct create my_app
```

### Handling Requests  

Aqueduct applications start with a `RequestSink` subclass, which declares routes:

```dart
import 'package:aqueduct/aqueduct.dart';

class AppRequestSink extends RequestSink {
  AppRequestSink(ApplicationConfig config) : super(config) {
    // Initialization method for each isolate
  }

  @override
  void setupRouter(Router router) {
    router
      .route("/resource")
      .generate(() => new ResourceController());
  }
}
```

The logic for request handling is typically declared in `HTTPController` subclasses, which are declared in their own file. A single `HTTPController` handles all HTTP requests for a collection of some resource or a single resource in that collection; e.g. POST /users, GET /users and GET /users/1 all go to the same object.

```dart
import 'package:aqueduct/aqueduct.dart'

class ResourceController extends HTTPController {
  @httpGet
  Future<Response> getAllResources() async {
    return new Response.ok(await fetchResources());
  }
}
```

Read YAML configuration data into type-safe structures at startup:

```
// config.yaml
database:
  host: ...
  port: 5432
  databaseName: foo
otherOption: hello
numberOfDoodads: 3  
```

```dart
import 'package:aqueduct/aqueduct.dart';

class AppRequestSink extends RequestSink {
  AppRequestSink(ApplicationConfig config) : super(config) {
    var options = new AppOptions(config.configurationFilePath);
    ...
  }
}

class AppOptions extends ConfigurationItem {
  DatabaseConnectionInfo database;
  String otherOption;
  int numberOfDoodads;
}
```


Aqueduct applications are run with a command line tool, which can also open debugging and instrumentation tools and specify how many threads the application should run on:

```
aqueduct serve --observe --isolates 5
```

Run applications detached or still connected to the shell (how a tool like Heroku expects):

```
aqueduct serve --detached --port $PORT
```

Aqueduct applications threads are isolated - they share no memory with other threads - and each runs a replica of the same web server. Pooling resources is effectively achieved through this mechanism.

### Working with Databases

Much of the time, a request is handled by sending one or more commands to a database to either get data or send data. This is done with `Query<T>` objects.

```dart
import 'package:aqueduct/aqueduct.dart'

class ResourceController extends HTTPController {
  @httpGet
  Future<Response> getAllResources() async {
    var query = new Query<Resource>();

    var results = await query.fetch();

    return new Response.ok(results);
  }
}
```

The results of a `Query<T>` can be filtered by configuring its `where` property, which uses Dart's powerful, real-time static analyzer to avoid mistakes and offer code completion.

```dart
var query = new Query<Employee>()
  ..where.name = whereStartsWith("Sa")
  ..where.salary = whereGreaterThan(50000);
var results = await query.fetch();
```

The same analysis tool helps build queries to insert or update values into the database:

```dart
var query = new Query<Employee>()
  ..values.name = "Bob"
  ..values.salary = 50000;

var bob = await query.insert();  

var updateQuery = new Query<Employee>()
  ..where.id = bob.id
  ..values.name = "Bobby";
var bobAgain = await bob.updateOne();  
```

`Query<T>`s can sort and page on a result set. It can also join tables and returned objects and their relationships:

```dart
var query = new Query<Employee>()
  ..where.name = "Sue Gallagher"
  ..joinOne((e) => e.manager)
  ..joinMany((e) => e.directReports);

var herAndHerManagerAndHerDirectReports = await query.fetchOne();
```

Database rows are represented by subclasses of `ManagedObject<T>` - also the type argument to `Query<T>`.

```dart
class Employee extends ManagedObject<_Employee> implements _Employee {
  bool get wasRecentlyHired => hireDate.difference(new DateTime.now()).inDays < 30;
}
class _Employee  {
  @managedPrimaryKey
  int index;

  @ManagedColumnAttributes(indexed: true)
  String name;

  DateTime hireDate;
  int salary;
}
```

`ManagedObject<T>`s have relationship properties - references to other `ManagedObject<T>`s.

```dart
class Employee extends ManagedObject<_Employee> implements _Employee {}
class _Employee {
  ManagedSet<Initiative> initiatives;

  ...
}

class Initiative extends ManagedObject<_Initiative> implements _Initiative {}
class _Initiative {
  @ManagedRelationship(#initiatives)
  Employee leader;

  ...
}
```

Run database migrations with the `aqueduct db` tool:

```
aqueduct db generate
aqueduct db upgrade --connect postgres@://...
```


### OAuth 2.0

Authentication and authorization are enabled at application startup by creating an `AuthServer` with `ManagedAuthStorage` from `aqueduct/managed_auth`:

```dart
import 'package:aqueduct/aqueduct.dart';
import 'package:aqueduct/managed_auth.dart';

class AppRequestSink extends RequestSink {
  AppRequestSink(ApplicationConfig config) : super(config) {
    var storage = new ManagedAuthStorage<User>(ManagedContext.defaultContext);
    authServer = new AuthServer(storage);
  }

  AuthServer authServer;
}
```

Set up routes to exchange credentials for tokens, using `AuthController` and `AuthCodeController`. Add `Authorizer`s between routes and their controller to restrict access to authorized users only:

```dart
void setupRouter(Router router) {
  router
    .route("/auth/token")
    .generate(() => new AuthController(authServer));

  router
    .route("/auth/code")
    .generate(() => new AuthCodeController(authServer));

  router
    .route("/protected")
    .pipe(new Authorizer.bearer(authServer))
    .generate(() => new ProtectedController());
}
```

Insert OAuth 2.0 clients into a database:

```
aqueduct auth add-client --id com.app.mobile --secret foobar --redirect-uri https://somewhereoutthere.com
```

### Logging

Set up logging to run on a separate thread and write to the console or a rotating file log at application startup:

```dart
class WildfireSink extends RequestSink {
  static String LoggingTargetKey = "logging";

  static Future initializeApplication(ApplicationConfiguration config) async {    
    ...
    var loggingServer = new LoggingServer([new ConsoleBackend()]);
    await loggingServer?.start();
    config.options[LoggingTargetKey] = loggingServer?.getNewTarget();
  }

  WildfireSink(ApplicationConfiguration config) : super(config) {
    var target = config.options[LoggingTargetKey];
    target?.bind(logger);

    logger.info("We're up!");
  }
}
```

### Testing

Because Aqueduct can generate database migration files, it can generate your application data model schema on the fly, too. Starting a test instance of an application will connect to a temporary database and create tables that are destroyed when the database connection closes. Endpoints are validated with specialized matchers in the Hamcrest matcher style:

```dart
test("/users/1 returns a user", () async {
  var response = await testClient.authenticatedRequest("/users/1").get();
  expect(response, hasResponse(200, partial({
    "id": 1,
    "name": isString
  })));
});
```

Use the template project's test harness to quickly set up tests:

```dart
import 'package:test/test.dart';
import 'package:my_app/my_app.dart';

void main() {
  TestApplication app = new TestApplication();

  setUpAll(() async {
    await app.start();
  });

  test("...", () async {
    var response = await app.client.request("/endpoint").get();
    ...
  });
}
```

### Documentation

Generate OpenAPI specifications automatically:

```
aqueduct document
```
